////  basicFunction.cpp//  SqList////  Created by ringggr on 17/6/1.//  Copyright © 2017年 Jacky(HJQ). All rights reserved.//#include "basicFunction.hpp"void ListInsert(SqList &L, int i, int e){    if (i < 1 || i > L.length + 1)    {        return ;    }    if (L.length >= MaxSize)    {        return ;    }    for (int j = L.length; j >= i; j--)    {        L.data[j] = L.data[j - 1];    }    L.data[i - 1] = e;    L.length++;    return ;}bool ListDelete(SqList &L, int i, int &e){    if (i < 1 || i > L.length)    {        return false;    }    e = L.data[i - 1];    for (int j = i - 1; j < L.length - 1; j++)    {        L.data[j] = L.data[j + 1];    }    L.length--;    return true;}int LocateElem(SqList &L, int e){    for (int i = 0; i < L.length; i++)    {        if (e == L.data[i])        {            return i + 1;        }    }    return 0;}void Print(SqList &L){    cout << "-----------------------------------" << endl;    for (int i = 0; i < L.length; i++)    {        cout << L.data[i] << ' ';    }    cout << endl;    cout << "-----------------------------------" << endl;}/////////////////////////////////////void Reverse(int a[], int left, int right){    while (left < right)    {        int temp = a[left];        a[left] = a[right];        a[right] = temp;        left++;        right--;    }}//关于动态void SeqCreate(SeqList &L){    L.data = new int[InitSize];    L.cap = InitSize;    L.length = 0;}void SeqDestroy(SeqList &L){    free(L.data);    L.data = NULL;    L.cap = L.length = 0;}void SeqInsert(SeqList &L, int p, int e){    if (p < 1 || p > L.length + 1)    {        cout << "error position" << endl;    }    else    {        if (L.length == L.cap)        {            SeqResize(L, L.cap + InitSize);        }        for (int i = L.length; i >= p; i--)        {            L.data[i] = L.data[i - 1];        }        L.data[p - 1] = e;        L.length++;    }}int SeqPosReturn(SeqList &L, int pos){    return L.data[pos - 1];}void SeqAdd(SeqList &L, int e){    if (L.length == L.cap)    {        SeqResize(L, L.cap + InitSize);    }    L.data[L.length++] = e;}void SeqRemove(SeqList &L, int i, int &e){    if (i < 1 || i > L.length)    {        cout << "error position"  << endl;    }    else    {        e = L.data[i - 1];        for (int j = i; j < L.length; j++)        {            L.data[j - 1] = L.data[j];        }        L.length--;    }}void SeqClear(SeqList &L){    L.length = 0;}void SeqInput(SeqList &L){    }void SeqOutput(SeqList &L){    putchar('(');    for (int i = 0; i < L.length; i++)    {        cout << L.data[i] << ' ';    }    putchar(')');    cout << endl;}void SeqReverse(SeqList &L, int left, int right){    //int mid = (left + right) / 2;    left--;    right--;    if (right <= left || right > L.length)    {        return;    }    while (left < right)    {        int temp = L.data[left];        L.data[left] = L.data[right];        L.data[right] = temp;        left++;        right--;    }}void SeqResize(SeqList &L, int newSize){    int *a;    if (newSize >= L.length)    {        L.cap = newSize;        a = new int[newSize];        for (int i = 0; i < L.length; i++)        {            a[i] = L.data[i];        }        free(L.data);        L.data = a;    }}bool quest1(SqList &L, int &e){    //int tag;    if (L.length < 1)    {        cout << "Empty!" << endl;        return false;    }    int pos = 0;    e = L.data[0];    for (int i = 0; i < L.length; i++)    {        if (L.data[i] < e)        {            pos = i;            e = L.data[pos];        }    }    L.data[pos] = L.data[L.length - 1];    return true;}void quest2(SqList &L)//逆置{    int p;    for (int i = 0; i < L.length / 2; i++)    {        int j = L.length - 1 - i;        p = L.data[i];        L.data[i] = L.data[j];        L.data[j] = p;    }}void quest3(SqList &L, int e)//删除所有值为e的{    int n = 0;    for (int i = 0; i < L.length; i++)    {        if (L.data[i] != e)        {            L.data[n++] = L.data[i];        }    }    L.length = n;}void quest4(SqList &L, int s, int t)//有序删除在s、t之间的值{    if (L.length == 0 || s >= t)    {        printf("error!\n");        return ;    }    int i, j;    for (i = 0; i < L.length && L.data[i] < s; i++);    if (i >= L.length)    {        printf("error!\n");        return ;    }    for (j = i; j < L.length && L.data[j] <= t; j++);    for (;j < L.length; i++, j++)    {        L.data[i] = L.data[j];    }    L.length = i;}void insertSort(SqList &L){    for (int i = 0; i < L.length; i++)    {        int key = L.data[i];        int j = i - 1;        while (j >= 0 && L.data[j] > key)        {            L.data[j + 1] = L.data[j];            j--;        }        L.data[j + 1] = key;    }}void quest5(SqList &L, int s, int t)//无序下 删除在s、t之间的值{    int i, k = 0;    if (L.length == 0 || s >= t)    {        printf("error\n");        return ;    }    for (i = 0; i < L.length; i++)    {        if (L.data[i] >= s && L.data[i] <= t)        {            k++;        }        else{            L.data[i - k] = L.data[i];        }    }    L.length -= k;}void quest6(SqList &L)//delete same{    insertSort(L);    if (L.length == 0)    {        return ;    }    int i, j;    for (i = 0, j = 1; j < L.length; j++)    {        if (L.data[i] != L.data[j])        {            L.data[++i] = L.data[j];        }    }    L.length = i + 1;}SeqList quest7(SeqList &L, SeqList &M)//合并两有序表{    SeqList temp;    SeqCreate(temp);    int i = 0, j = 0;    int pos = 1;    while (i < L.length && j < M.length)    {        if (L.data[i] < M.data[j])        {            SeqInsert(temp, pos++, L.data[i++]);        }        else        {            SeqInsert(temp, pos++, M.data[j++]);        }    }    while (i < L.length) {        SeqInsert(temp, pos++, L.data[i++]);    }    while (j < M.length) {        SeqInsert(temp, pos++, M.data[j++]);    }    return temp;}void quest8(int a[], int m, int n)//将一个数组的前后两个线性表（前面的m个， 后面的n个）交换位置{    SeqList sl1, sl2;    SeqCreate(sl1);    SeqCreate(sl2);    for (int i = 0; i < m; i++)    {        SeqAdd(sl1, a[i]);    }    for (int i = m; i < m + n; i++)    {        SeqAdd(sl2, a[i]);    }    int i;    for (i = 0; i < n; i++)    {        a[i] = SeqPosReturn(sl2, i + 1);    }    for (int j = 0;j < m; j++)    {        a[i++] = SeqPosReturn(sl1, j + 1);    }}void quest9(SeqList &L, int e)//在升序数组a中查找e元素，存在则与最后元素交换，不存在则插入至正确位置{    int low = 0, high = L.length - 1, mid = 0;    while (low <= high)    {        mid = (low + high) / 2;        if (L.data[mid] == e) break;        else if (L.data[mid] < e)        {            low = mid + 1;        }        else        {            high = mid - 1;        }    }        if (L.data[mid] == e && mid != L.length - 1)    {        int temp = L.data[L.length - 1];        L.data[L.length - 1] = L.data[mid];        L.data[mid] = temp;    }    cout << endl << low << ' ' << high << endl;    if (low > high)    {//        cout << "nothing";        for (int i = L.length - 1; i > high; i--)        {            L.data[i + 1] = L.data[i];        }        L.data[high + 1] = e;        L.length++;    }}void quest10(int a[], int n, int p)//数组循环左移p位{    Reverse(a, 0, p - 1);    Reverse(a, p, n - 1);    Reverse(a, 0, n - 1);}int quest11(int a[], int b[], int n)//求两个长度相等的数组的中位数{    int i = 0, j = 0, pos = 0, res = 0;    while (pos < n)    {        if (a[i] < b[j])        {            res = a[i++];        }        else        {            res = b[j++];        }        pos++;    }    return res;}int quest11_2(int a[], int b[], int n)//时间复杂度O(log2n){    int s1 = 0, d1 = n - 1, m1,s2 = 0, d2 = n - 1, m2;    while (s1 != d1 || s2 != d2)    {        m1 = (s1 + d1) / 2;        m2 = (s2 + d2) / 2;        if (a[m1] == b[m2])        {            return a[m1];        }        if (a[m1] < b[m2])        {            if ((s1 + d1) % 2 == 0)            {                s1 = m1;                d2 = m2;            }            else{                s1 = m1 + 1;                d2 = m2;            }        }        else        {            if ((s2 + d2) % 2 == 0)            {                d1 = m1;                s2 = m2;            }            else            {                d1 = m1;                s2 = m2 + 1;            }        }    }    return a[s1] < b[s2] ? a[s1] : b[s2];}int quest12(int a[], int n)//求主元素{    int num = -1, cnt = 0;    for (int i = 0; i < n; i++)    {        if (a[i] == num)        {            cnt++;        }        else if (a[i] != num && cnt)        {            cnt--;        }        else {            num = a[i];            cnt++;        }    }    if (cnt)    {        cnt = 0;        for (int i = 0; i < n; i++)        {            if (a[i] == num)            {                cnt++;            }        }        if (cnt > n / 2)        {            return num;        }    }    return -1;}